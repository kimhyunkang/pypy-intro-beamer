\documentclass[slidestop]{beamer}
\usepackage{kotex}
\usepackage{hyperref}
\usepackage[accumulated]{beamerseminar}
\usepackage{beamertexpower}
\usepackage{beamerthemeGoettingen}
\usepackage{beamercolorthemebeaver}

\usepackage{graphicx}

\addtobeamertemplate{block begin}{}{\setlength{\parskip}{35pt plus 1pt minus 1pt}}

\title{PyPy - A Python Interpreter written in Python}
\author[]{모비젠 플랫폼연구팀 김현강\\\code{kimhyunkang@mobigen.com}}
\date{}

\begin{document}

%% 표지
\begin{slide}

\maketitle

\end{slide}

\section{PyPy - 소개}
\frame{
\begin{slide}
\frametitle{PyPy}

  \includegraphics[width=0.8\textwidth]{Pypy_logo} \\
  \url{http://pypy.org}

  \begin{itemize}
  \item Python으로 작성한 Python 구현체
  \item CPython(표준 인터프리터)은 인터프리터가 모두 C로 작성되어 있습니다
  \item 반면 PyPy는 전부 Python으로 작성되어 있습니다
  \end{itemize}

\end{slide}
}

\frame{
\begin{slide}
\frametitle{PyPy의 역사}

  \begin{itemize}
  \item psyco의 개발자 Armin Rigo가 개발하였습니다
  \item 2007년 1.0 릴리즈가 발표되었습니다
  \item 현재 최신 릴리즈는 1.9이며, 2.0 베타가 발표되어 테스트 중에 있습니다
  \item Python 2.7.3 문법을 모두 지원하며, Python 3은 아직 지원하지 않습니다
    \begin{itemize}
    \item 일부 표준 라이브러리는 지원하지 않습니다
    \end{itemize}
  \end{itemize}

\end{slide}
}

\section{Bootstrapping}
\frame{
\begin{slide}
\frametitle{Bootstrapping}

  대상 언어로 대상 언어의 컴파일러를 짜는 테크닉을 bootstrapping이라고 합니다

  bootstrapping은 컴파일러에서 흔히 사용되는 테크닉입니다
  \begin{itemize}
  \item GCC (C)
  \item Microsoft Visual C++
  \item Sun JDK
  \item Perl 6
  \item GHC (Haskell)
  \end{itemize}
\end{slide}
}

\frame{
\begin{slide}
\frametitle{Bootstrapping}
  Bootstrapping의 장점
  \begin{itemize}
  \item 해당 언어에 대해서만 잘 알면 컴파일러/인터프리터를 잘 만들 수 있습니다
  \item 다른 아키텍처로 포팅하기가 쉽습니다
  \item 컴파일러/인터프리터가 최적화된 코드를 만들면 런타임뿐만 아니라 컴파일러/인터프리터의 속도가 함께 빨라집니다
  \item 더 낮은 레벨의 언어로 작성된 컴파일러에 비해, bootstrapping으로 작성된 컴파일러는 더 간결한 소스코드를 갖게 됩니다
  \end{itemize}
\end{slide}
}

\frame{
\begin{slide}
\frametitle{PyPy의 장점}
  빠릅니다
  \begin{itemize}
  \item 프로그램의 종류에 따라 다르지만, 순수 파이썬으로 작성된 프로그램의 경우 보통 2배 이상 빠릅니다
  \item 특히 loop에서 빠릅니다 (뒤에서 설명)
  \end{itemize}

  메모리를 더 잘 관리합니다
  \begin{itemize}
  \item 자료구조에 따라 메모리를 50\% 가량 절약할 수 있습니다
  \item CPython보다 garbage collector 성능이 더 좋습니다
  \end{itemize}
\end{slide}
}

\section{PyPy 성능의 비밀}
\frame{
\begin{slide}
\frametitle{PyPy 성능의 비밀}
  파이썬으로 짠 인터프리터가 어떻게 CPython보다 빠를 수 있나요?
  \begin{itemize}
  \item PyPy를 CPython으로 돌릴 수도 있습니다
    \begin{itemize}
    \item 당연하게도 느립니다 (CPython의 200배 정도)
    \end{itemize}
  \item PyPy는 Python의 부분집합인 RPython으로 만들어져 있습니다
  \end{itemize}
\end{slide}
}

\subsection{RPython}
\frame{
\begin{slide}
\frametitle{PyPy가 빠른 이유 1 - RPython}
  PyPy 인터프리터의 파이썬 소스코드는 RPython이라는 컴파일러를 통해 C로 번역됩니다
  \begin{itemize}
  \item 컴파일 시 각 변수의 타입을 분석하여 그에 해당하는 C 타입으로 번역됩니다
  \item 인터프리터의 소스코드는 Python이지만, 실제로는 C 언어를 거쳐 다시 어셈블리로 번역되므로 인터프리터의 실행속도는 빠릅니다
  \item C외에 JVM이나 .net 바이트코드로 번역할 수도 있습니다
  \item 이 경우 JVM이나 .net에서 Python을 실행할 수 있습니다
  \end{itemize}
\end{slide}
}

\subsection{JIT Compilation}
\frame{
\begin{slide}
\frametitle{PyPy가 빠른 이유 2 - JIT Compilation}
  Python의 여러가지 기능을 지원하기 위해 CPython은 모든 코드마다 여러가지 체크를 수행합니다 
  \begin{itemize}
  \item 인터프리터가 \textbf{a+b} 를 실행할 때 일어나는 일
  \item 오브젝트 \textbf{a}가 \textbf{\_\_add\_\_} 연산자를 갖고 있는지 검사합니다
  \item 없을 경우 \textbf{b}가 \textbf{\_\_radd\_\_} 연산자를 갖고 있는지 검사합니다
  \item 둘 중에 하나가 있다면, 두 값의 타입을 검사하여 coercion을 수행합니다
  \item 실제 덧셈이 수행됩니다
  \end{itemize}
\end{slide}
}

\frame{
\begin{slide}
\frametitle{PyPy가 빠른 이유 2 - JIT Compilation}
  PyPy는 파이썬 코드를 실행할 때 일부 코드를 해당 CPU의 기계어로 직접 번역합니다
  \begin{itemize}
  \item 이런 테크닉을 Just-in-time 컴파일이라고 하며, Java VM이 빠른 이유이기도 합니다
  \item 모든 코드를 기계어로 번역하는 것은 실행시간보다 컴파일 시간이 오래 걸리므로 낭비입니다
  \item 루프 내의 코드나 자주 호출되는 함수를 찾아내어 기계어로 번역합니다
  \end{itemize}
\end{slide}
}

\subsection{Garbage Collector}
\frame{
\begin{slide}
\frametitle{PyPy가 빠른 이유 3 - Garbage Collector}
  CPython은 reference-count로 메모리를 관리하지만, PyPy는 tracing garbage collector를 사용합니다
  \begin{itemize}
  \item Reference-Counting Memory Management
    \begin{itemize}
    \item 모든 CPython 변수에는 몇개의 변수가 자기 자신을 가리키고 있는지 추적하는 값이 붙어 있으며, 이 숫자가 0이 될때 메모리에서 제거합니다
    \item 따라서, 모든 변수가 메모리를 4바이트씩 더 사용합니다
    \end{itemize}
  \item Tracing Garbage Collector
    \begin{itemize}
    \item 반면 PyPy는 주기적으로 한 변수가 다른 변수를 가리키는 포인터를 모두 추적한 후 쓰이지 않는 메모리를 모아 삭제합니다
    \end{itemize}
  \end{itemize}

  잘 최적화된 Tracing GC는 대부분의 경우 Reference-Counting보다 효율적이라는 것이 여러 컴파일러(특히 JVM)에서 증명되어 있습니다
\end{slide}
}

\end{document}
